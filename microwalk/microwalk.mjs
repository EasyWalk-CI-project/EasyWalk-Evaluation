/**
 * Holds utility functions for writing Microwalk wrappers.
 */

import * as crypto from "node:crypto";

// The seed used for the RNG overrides.
let _seed = 0;


/**
 * Prints the given error message and terminates.
 * 
 * @param {string} message Error message.
 */
export function exit_with_error(message)
{
    console.error(`ERROR in wrapper: ${message}`);
    process.exit(1);
}

/**
 * Prints the given byte array in hex notation to standard output.
 * 
 * @param {Buffer|Uint8Array} buffer Buffer object to print.
 * @param {string} name Name of the buffer (optional).
 * @param {boolean} indent Whether to indent the output so it fits well with the test case marker logs.
 */
export function print_buffer(buffer, name = null, indent = true)
{
    if(buffer instanceof Uint8Array)
        buffer = Buffer.from(buffer);

    if(name)
        console.log((indent ? "    " : "") + name + ":", buffer.toString("hex"));
    else
        console.log((indent ? "    " : "") + buffer.toString("hex"));
}

/**
 * Performs some initialization.
 * 
 * @returns {Promise<void>} Promise that resolves when the initialization is done.
 */
export async function init()
{
    let nativeCrypto = await import("node:crypto");
    
    // Override webcrypto RNG
    nativeCrypto.webcrypto.getRandomValues = (buffer) => {
        buffer.set(generateRandomBytes(_seed, { length: buffer.byteLength }, null, null));
        _seed = (19 * _seed + 17) % Number.MAX_SAFE_INTEGER; // Ensure that we get different random values next time
        return buffer;
    };
}

/**
 * Sets the seed used for the RNG overrides.
 */
export function set_seed(seed)
{
    _seed = seed;
}


/**
 * Generates random bytes depending on the given seed.
 * 
 * @param {Number} seed Seed for the random number generator.
 * @param {Object} params Parameters for the random number generation.
 * @param {Object} subtargetInfo Subtarget info object (ignored).
 * @param {String} subtargetKey Subtarget key.
 * @returns {Buffer} Buffer object containing the generated bytes.
 */
export function generateRandomBytes(seed, params, subtargetInfo, subtargetKey)
{
    subtargetKey = subtargetKey ?? "(unknown)";

    let testcaseLength = params.length;
    if(!testcaseLength)
        exit_with_error(`Missing length parameter for random testcase generation function for subtarget ${subtargetKey}`);

    // Hash seed
    const hash = crypto.createHash("sha256");
    hash.update(seed.toString());
    const hashBuffer = hash.digest();

    const buffer = Buffer.alloc(testcaseLength);
    buffer.fill(0);

    // Encrypt buffer with AES-256 using the hash as key
    const cipher = crypto.createCipheriv("aes-256-ecb", hashBuffer, null);
    cipher.setAutoPadding(true);
    let output = Buffer.concat([cipher.update(buffer), cipher.final()]);

    // Shorten output if necessary
    if(output.length > testcaseLength)
        output = output.subarray(0, testcaseLength);
    
    return output;
}

/**
 * Generates random bytes and returns them as a hex string.
 * 
 * @param {Number} seed Seed for the random number generator.
 * @param {Object} params Parameters for the random number generation.
 * @param {Object} subtargetInfo Subtarget info object (ignored).
 * @param {String} subtargetKey Subtarget key.
 * @returns {String} Hex string containing the generated bytes.
 */
export function generateRandomBytesHex(seed, params, subtargetInfo, subtargetKey)
{
    const buffer = generateRandomBytes(seed, params, subtargetInfo, subtargetKey);
    return buffer.toString("hex");
}